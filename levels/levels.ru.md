Что такое уровни переопределния
Как они используются в проектах
Примеры применения 

## Что такое уровни переопределния

Уровень переопределения — это набор [реализаций блоков](), сгруппированных в одну директорию.

```files
project/
    level/               # уровень переопределния с набором блоков и их реализаций
        block1/
            __elem1/
                block1__elem1.js
            _mod1/
                block1_mod1.css
            block1.css
            block1.js
        block2/
            block2.css
            block2.js
        block3/
        block4/
```

Любой БЭМ-проект состоит из уровней переопределения. Количество уровней и содержащийся в них набор БЭМ-сущностей могут меняться. Но проект всегда состоит минимум из одного уровня переопределения. 

## Зачем нужны уровни переопределения ЧТО ДАЮТ УРОВНИ

Уровни переопределния — это группирующие директории в файловой структуре проекта, по которым распределяются все реализации блоков, элементов и модификаторов в проекте. 
Реализация блока может быть разделена по разным уровням переопределения или может находиться только на одном. 

Зачем это нужно: 

Если реализация блока разделена по уровням, то каждый новый уровень добавляет новые свойства (доопределяет, наследует) блоку или изменяет старые (переопределяет). 

Для сборки каждого бандла можно настроить свое используемое множество уровней. Финальная реализация блока на странице собирается со всех уровней для этой страницы. Чтобы получить желаемый конечный результат, в настройках сборщика надо указать, с каких уровней и в каком порядке собирать исходные файлы. 

Если сравнить уровни со слоями, то базовый слой – это исходная реализация блока, а каждый последующий слой накладывается сверху и дополняет (наследует) или изменяет базовую реализацию.

Нагляднее всего переопределение CSS-свойств блока:

```files
project/
    common/               # уровень переопределния 1 с набором блоков и их реализаций
        button/
            button.css
            button.js
    project/               # уровень переопределния 2 с набором блоков и их реализаций
        button/
            button.css
```


```files
project/
    common/               # уровень переопределния 1 с набором блоков и их реализаций
        button/
            button.css
                /* Блок button в технологии css на уровне common */

                    .button {
                        color: red;
                        height: 24px;
                    }

            button.js
    project/               # уровень переопределния 2 с набором блоков и их реализаций
        button/
            button.css
                /* Блок button в технологии css на уровне project */

                    .button {
                        color: green;
                        font-size: 11px;
                    }
```

```css
/* Блок button в технологии css на уровне common */

.button {
    color: red;
    height: 24px;
}

/* Блок button в технологии css на уровне project */

.button {
    color: green;
    font-size: 11px;
}
```

В результате сборки с двух уровней повторяющиеся свойства (`color:`) для блока `button` переопределятся (кнопка из красной превратится в зеленую), а новые свойства (`font-size: 11px;`) добавятся. 

```css
@import "common/button/button.css";    /* Базовые CSS-правила */
@import "project/button/button.css";   /* Особенности desktop */
```

Суммарный результат для блока `button` в технологии CSS:

```css
/* Результат сборки блока button в технологии css */

.button {
    color: green;
    height: 24px;
    font-size: 11px;
}
```

> Пример приведен для технологии CSS для большей наглядности. В БЭМ-проекте любая технология реализации блока может быть пере- или доопределена. Подробности в разделе (Платформа)[]. Можно переопределять не только CSS-свойства блока, но и его методы и шаблоны использования.
> Если нам нужно, на некоторой странице иметь некий superInput, который чем-то отличается от базового input, то нам не обязательно именно придумывать новое имя и новый блок. Можно создать pages/index/blocks/input/input.js и положить туда BEM.DOM.decl('input', ... тут декларация полей и методов ...), эта декларация будет себя вести в точности как наследник базового blocks/input/input.js, т.е. будут доступны правильные this.__base() и this.__self.

> На уровне переопределения проекта все блоки, определённые на уровне библиотеки блоков, расширяются с помощью API наследования. Это сделано по аналогии с CSS, ведь если на проекте есть blocks/input/input.css в котором .input { color: red }, то это будет расширять тот lib/blocks/input/input.css, который написан в библиотеке.


## ЗАЧЕМ НАМ ЭТО НУЖНО в реальных проектах

Помимо того, что уровни помогают избежать копирования кода и создания новых сущностей, если необходимо изменить уже существующую функциональность, они позволяют организовать архитектуру проекта:
* Подключать библиотеки и обновлять их, не делая правок в коде.
* Выделять общие части реализаций блоков на один уровень, а частные случаи (например, специфическую реализацию для отдельных сервисов) — на другой.
* Разделять проект на платформы. Общую реализацию для всех платформ хранить на одном уровне, а платформо-специфичную — выносить на другой.
* Экспериментировать в рабочем проекте.
* Иметь разные дизайны проекта с одной и той же бизнесс-логикой.

### Проект и библиотеки

В проект можно подключить библиотеку как отдельный уровень. Изменять (до- или переопределять) блоки можно на другом уровне проекта. При сборке подключится исходная реализация блоков с уровня библиотеки и переопределенная — с уровня проекта.

Такое разделение позволяет сохранить изменения в блоках при обновлении библиотеки. Код самой библиотеки обновится, а специфическая реализация блоков проекта останется прежней, так как находится на другом уровне проекта.

```files
library.blocks/
    button/
        button.css    # CSS-реализация кнопки в библиотеке (высота 20px)

project.blocks/
    button/
        button.css    # Переопределение на уровне проекта (высота 24px)
```


### Разделение проекта на платформы

Проект разделен на платформы (`mobile` и `desktop`) и соответствующие уровни переопределения в файловой структуре. Уровень `common` содержит общую реализацию блоков для всех платформ. На уровне `desktop` и `mobile` находится специфика реализаций блоков, характерная для каждой из платформ.

Рассмотрим на примере:

```files
common.blocks/
    button/
        button.css    # Базовая CSS-реализация кнопки

desktop.blocks/
    button/
        button.css    # Особенности кнопки для desktop

mobile.blocks/
    button/
        button.css    # Особенности кнопки для mobile
```

При сборке в файл `desktop.css` попадут все базовые CSS-правила кнопки с уровня `common` и переопределенные правила с уровня `desktop`.

```css
@import "common.blocks/button/button.css";    /* Базовые CSS-правила */
@import "desktop.blocks/button/button.css";   /* Особенности desktop */
```

Файл `mobile.css` будет включать базовые CSS-правила кнопки с уровня `common` и переопределенные правила с уровня `mobile`.

```css
@import "common.blocks/button/button.css";    /* Базовые CSS-правила */
@import "mobile.blocks/button/button.css";    /* Особенности mobile */
```


### Общая часть проекта и специфика

проект и сервисы

Если группа блоков одного проекта (объединённая в папку) подключена к другому проекту напрямую (при помощи частичного чекаута или svn:externals), то любое закоммиченное изменение в таких блоках повлияет на оба проекта.
При разработке одного сайта на основе существующего может потребоваться:
Увеличить шрифт в Шапке на всём сайте (не затрагивая предыдущий сайт),
Добавить анимацию для раскрытия всех выпадающих меню.
То есть необходима возможность переопределять (или доопределять) блоки в разных технологиях только для определённого сайта или только для определённых страниц. Это возможно благодаря уровням переопределения.



проект и дизайн



### Эксперименты

Another practical case of redefinition level usage is execute A/B testing in your project, without changing the code of the project itself.

**Example**

You have to make some requested changes in your project. For example, you have to change the header on all pages. You need to test all cases and choose the best one. To test the result and not to ruin your project or not to write long story about `if` statements, you just create new redefinition levels for tests on a project.

You could create as much levels as you want to test new functionality. 

```files
project/            # Project level that works good
    header/         # Current header block of the project
    ...
test-1/             # Level for test 1
    header/         # header block with some changes 
test-2/             # Level for test 2
    header/         # header block with some changes 
test-n/             # Level for test 3
    header/         # header block with some changes 
```

You could build your project including every test layer to view the results (e.g. `project` + changes from `test-1` or `project` + changes from `test-n` or `project` + changes from `test-1` and `test-2`). If some tests are not passed, you could just remove unacceptable layer with these tests from the project assembly. Nothing will crash the current project and affect other tests.


### 

###





Если сравнить уровни со слоями, то базовый слой – это исходная реализация блока, а каждый последующий слой накладывается сверху и дополняет (наследует) или изменяет базовую реализацию.


























1. Переопределения на уровнях
Если нам нужно, на некоторой странице иметь некий superInput, который чем-то отличается от базового input, то нам не обязательно именно придумывать новое имя и новый блок. Можно создать pages/index/blocks/input/input.js и положить туда BEM.DOM.decl('input', ... тут декларация полей и методов ...), эта декларация будет себя вести в точности как наследник базового blocks/input/input.js, т.е. будут доступны правильные this.__base() и this.__self.

На уровне переопределения проекта все блоки, определённые на уровне библиотеки блоков, расширяются с помощью API наследования. Это сделано по аналогии с CSS, ведь если на проекте есть blocks/input/input.css в котором .input { color: red }, то это будет расширять тот lib/blocks/input/input.css, который написан в библиотеке.














Уровни переопределения (http://www.artiom.pro/2012/09/blog-post.html)
Если группа блоков одного проекта (объединённая в папку) подключена к другому проекту напрямую (при помощи частичного чекаута или svn:externals), то любое закоммиченное изменение в таких блоках повлияет на оба проекта.
При разработке одного сайта на основе существующего может потребоваться:
Увеличить шрифт в Шапке на всём сайте (не затрагивая предыдущий сайт),
Добавить анимацию для раскрытия всех выпадающих меню.
То есть необходима возможность переопределять (или доопределять) блоки в разных технологиях только для определённого сайта или только для определённых страниц. Это возможно благодаря уровням переопределения.
Уровень переопределения — это набор реализаций блоков, сгруппированных в одну директорию.

Реализация любого блока библиотеки может быть расширена (или переопределена) на уровне проекта.

С точки зрения сборки страниц:
При сборке каждой страницы можно указать список уровней (директорий), блоки которых будут представлены на странице. Например,
build-page -l blocks-common -l blocks-my my-page.html
С точки зрения файловой структуры:
Проект можно содержать любое количество реализаций блоков. Но на страницу попадут только те, которые явно указаны к применению для сборки этой страницы. Возможно делать разные наборы уровней переопределения для разных разделов сайтов.
С точки зрения JavaScript
Необходима возможность декларативного описания динамического поведения элементов на странице. Конечное поведение должно собираться с разных уровней переопределения. Например,
/* blocks-common/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    ...
  }
});

/* blocks-my/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    this.__base();
    ...
  }
});
С точки зрения шаблонного движка
Для того, чтобы можно было не только переопределять, но и "доопределять" шаблон, нужна возможность вызвать предыдущую реализацию шаблона.
Например, в случае xsl:
<xsl:template match="b:head">
  <div> <!-- Node for extra design -->
    <xsl:apply-imports/>
  </div>
</xsl:template>
С точки зрения архитектуры проекта
При разработке портала из нескольких сайтов можно выделить общую библиотеку блоков, которая станет одним из уровней переопределения для всех сайтов портала. Блоки конкретного сайта — объединить в другой уровень переопределения.
В одном и том же репозитории может храниться реализация сайта для десктопных и мобильных браузеров.
В таком проекте есть уровень переопределения для общей реализации блоков, для мобильной и для десктопной. Различные комбинации уровней дают желаемую реализацию блоков на конкретных страницах.
Примером реализации нескольких уровней переопределения в одном репозитории может служить Open Source библиотека блоков bem-bl.














Уровни переопределения дают возможность:

* расширять или перекрывать исходную реализацию БЭМ-сущностей.
* подключать в проект дополнительные БЭМ-сущности (например, готовые блоки из сторонней библиотеки).
* Настраивать сборку проекта. Логически разделять сборку по требованию проекта. 
