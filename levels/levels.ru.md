Что такое уровни переопределния
Как они используются в проектах
Примеры применения 

## Что такое уровни переопределния

Уровень переопределения — это набор полных или частичных [реализаций]() [блоков](), [элементов]() и [модификаторов]().

В файловой структуре проекта уровень переопределния выглядит как группирующая директория, которая содержит директории БЭМ-сущностей с их исходными файлами реализаций. 

```files
project/
    level/                              # уровень переопределния
        block1/                         # директория блока block1
            __elem1/                    # директория элемента elem1 блока block1
                block1__elem1.js        # исходный файл реализации элемента elem1 блока block1 в технологии JavaScript
            _mod1/                      # директория модификатора mod1 блока block1
                block1_mod1.css         # исходный файл реализации модификатора mod1 блока block1 в технологии CSS
            block1.css                  # исходный файл реализации блока block1 в технологии CSS
            block1.js                   # исходный файл реализации блока block1 в технологии JavaScript
        block2/                         # директория блока block2
            block2.css                  # исходный файл реализации блока block2 в технологии CSS
            block2.js                   # исходный файл реализации блока block1 в технологии JavaScript
        block3/
        block4/
```

Любой БЭМ-проект включает минимум один уровень переопределения. Количество уровней и содержащийся в них набор БЭМ-сущностей могут меняться.

> [Подробнее о файловой структуре БЭМ-проекта]()

## Зачем нужны уровни переопределения

Уровни переопределения дают возможность:

* расширять или перекрывать исходную реализацию БЭМ-сущностей.
* подключать в проект дополнительные БЭМ-сущности (например, готовые блоки из сторонней библиотеки).
* Настраивать сборку проекта. Логически разделять сборку по требованию проекта. 

### Изменение реализации блока

В БЭМ-методологии реализация блока распределена по отдельным файлам технлогий (`button.css`, `button.js`, `button.tests`), которые сгруппированы в файловой структуре по-блочно. Такая организация файловой структуры проекта позволяет по-разному хранить/ реализацию блока: 

* на одном уровне переопределния; 
* разделять по разным уровням.

> [Почему так?](https://ru.bem.info/methodology/filestructure/) 

Обычная структура проекта —> структрура БЭМ-проекта

Реализация блока в любой из технологий может находиться только на одном уровне переопределния, а может быть разделена по разным. Во втором случае каждый последующий уровень добавляет новые свойства (доопределяет, наследует) блоку или изменяет старые (переопределяет).

Финальная реализация блока собирается со всех уровней последовательно в указанном порядке. Чтобы получить желаемый конечный результат, в настройках сборщика надо указать, с каких уровней и в каком порядке собирать исходные файлы. 

> **Примечание** Файлы, полученные в результате сборки, в БЭМ-методологии принято называть бандлами. Подробности [здесь](https://ru.bem.info/methodology/build/).

Для сборки каждого бандла можно настроить свое используемое множество уровней и порядок подключения.

Если сравнить уровни со слоями, то базовый слой – это исходная реализация блока, а каждый последующий слой накладывается сверху и дополняет (наследует) или изменяет базовую реализацию.

Нагляднее всего переопределение CSS-свойств блока:

```files
project/
    common/                # уровень переопределния common
        button/
            button.css
            button.js
    project/               # уровень переопределния project
        button/
            button.css
```


```css
/* Блок button в технологии CSS на уровне common */

.button {
    color: red;
    height: 24px;
}

/* Блок button в технологии CSS на уровне project */

.button {
    color: green;
    font-size: 11px;
}
```

В результате сборки с двух уровней повторяющиеся свойства (`color`) для блока `button` переопределятся (кнопка из красной превратится в зеленую), а новое свойство (`font-size`) добавится. 


В результате сборки: 
* повторяющиеся свойства (`color`) для блока `button` переопределятся (кнопка из красной превратится в зеленую);
* новое свойство (`font-size`) добавится. 


```css
@import "common/button/button.css";    /* Базовые CSS-правила */
@import "project/button/button.css";   /* Особенности desktop */
```

Финальный результат для блока `button` в технологии CSS:

```css
/* Результат сборки блока button в технологии CSS */

.button {
    color: green;
    height: 24px;
    font-size: 11px;
}
```

### Подключение дополнительных БЭМ-сущностей

С помощью уровней переопределния можно не только изменять уже существующие БЭМ-сущности, но и добавлять новые.

* [Добавление модификатора](#Добавление-модификатора)
* [Добавление блока](#Добавление-блока)

### Добавление модификатора

```files
project/
    common/                             # уровень переопределния common
        button/
            button.css
            button.js
    project/                            # уровень переопределния project
        button/
            _theme/
                button_theme_gold.css   # блоку button добавлен модификатор theme в значении gold 
```


```css
/* Блок button в технологии CSS на уровне common */

.button {
    color: red;
    height: 24px;
}

/* Модификтаор theme в значении gold блока button в технологии CSS на уровне project */

.button_theme_gold {
    color: yellow;
    font-size: 11px;
    text-align: center;
}
```

Если в DOM-дереве на одном DOM-узле будут присутствовать и селектор блока `button`, и его модификтора `theme` в значении `gold`, 

```html
<div class="button"></div>
<div class="button button_theme_gold"></div>

то результирующий файл CSS для блока `button` будет:

```css
/* Результат сборки блока button в технологии CSS */

.button {
    color: yellow;
    height: 24px;
    font-size: 11px;
    text-align: center;
}
```

> **Примечание** Можно переопределять не только CSS-свойства блока, но и его методы и шаблоны использования. В БЭМ-проекте любая технология реализации блока может быть пере- или доопределена. Подробности в разделе [Платформа](). 


### Добавление блока

Полная реализация блока может находится на отдельном уровне переопределения и подключаться в проект при сборке.

В проекте на разных уровнях расположены блоки. 

```files
project/
    common/                             # уровень переопределния common
        button/
            button.css
            button.js
    project/                            # уровень переопределния project
        logo/                           # блок logo 
            logo.css                    # реализация блока logo в технологии CSS
```

Чтобы блок `logo` с уровня `project` попал в сборку бандла необходимо:

* указать блок лого в файла с описанием блоков, которые в нем используются
* в настройках сборщика указан уровень переопределения `project`

```css
@import "common/button/button.css";     /* CSS-правила блока button */
@import "project/logo/logo.css";        /* CSS-правила блока logo */
```

Бандл строится на основании файла с описанием блоков, которые в нем используются, и файла, которые указывает на расположение этих блоков на странице. Это исходный код самого бандла. Из него генерируются все необходимые для отображения файлы (`.css`, `.js` и другие). Если блок `logo` присутсвует в исходном коде для построения бандла, и в настройках сборщика указан уровень переопределения `project`, то блок `logo` будет включен в сборку.

### Умная сборка и организация архитектуры проекта

Помимо того, что уровни помогают избежать копирования кода и создания новых сущностей, если необходимо изменить уже существующую функциональность, они позволяют организовать архитектуру проекта:
* Подключать библиотеки и обновлять их, не делая правок в коде.
* Выделять общие части реализаций блоков на один уровень, а частные случаи (например, специфическую реализацию для отдельных сервисов) — на другой.
* Разделять проект на платформы. Общую реализацию для всех платформ хранить на одном уровне, а платформо-специфичную — выносить на другой.
* Экспериментировать в рабочем проекте.
* Иметь разные дизайны проекта с одной и той же бизнесс-логикой.

### Проект и библиотеки

В проект можно подключить библиотеку как отдельный уровень. Изменять (до- или переопределять) блоки можно на другом уровне проекта. При сборке подключится исходная реализация блоков с уровня библиотеки и переопределенная — с уровня проекта.

Такое разделение позволяет сохранить изменения в блоках при обновлении библиотеки. Код самой библиотеки обновится, а специфическая реализация блоков проекта останется прежней, так как находится на другом уровне проекта.

```files
library.blocks/
    button/
        button.css    # CSS-реализация кнопки в библиотеке (высота 20px)

project.blocks/
    button/
        button.css    # Переопределение на уровне проекта (высота 24px)
```


Рассмотрим на примере, что из себя представляют svn:externals. Предположим, у нас есть проект, в котором используется сторонний open-source код, например, известная PDF библиотека iText. Обычно мы полностью копируем весь необходимый код этой библиотеки к себе в репозиторий. Впоследствии, при выходе обновлений iText, вручную заменяем старые файлы на новые.


### Разделение проекта на платформы

Проект разделен на платформы (`mobile` и `desktop`) и соответствующие уровни переопределения в файловой структуре. Уровень `common` содержит общую реализацию блоков для всех платформ. На уровне `desktop` и `mobile` находится специфика реализаций блоков, характерная для каждой из платформ.

Рассмотрим на примере:

```files
common.blocks/
    button/
        button.css    # Базовая CSS-реализация кнопки

desktop.blocks/
    button/
        button.css    # Особенности кнопки для desktop

mobile.blocks/
    button/
        button.css    # Особенности кнопки для mobile
```

При сборке в файл `desktop.css` попадут все базовые CSS-правила кнопки с уровня `common` и переопределенные правила с уровня `desktop`.

```css
@import "common.blocks/button/button.css";    /* Базовые CSS-правила */
@import "desktop.blocks/button/button.css";   /* Особенности desktop */
```

Файл `mobile.css` будет включать базовые CSS-правила кнопки с уровня `common` и переопределенные правила с уровня `mobile`.

```css
@import "common.blocks/button/button.css";    /* Базовые CSS-правила */
@import "mobile.blocks/button/button.css";    /* Особенности mobile */
```


### Общая часть проекта и специфика

#### проект и сервисы

часто приходится делать похожие проекты. Это могут быть похожие страницы в портале или типовые проекты 

В таком случае для разработки чего-то нового берут уже существующий проект и дальше наращивают изменения. Однако, если группа блоков одного проекта (объединённая в папку) подключена к другому проекту напрямую (при помощи частичного чекаута или внешних зависимостей, например, svn:externals), то любое закоммиченное изменение в таких блоках повлияет на оба проекта.

То есть необходима возможность переопределять (или доопределять) блоки в разных технологиях только для определённого сайта или только для определённых страниц. Это возможно благодаря уровням переопределения.

При разработке одного сайта на основе существующего может потребоваться:
Увеличить шрифт в Шапке на всём сайте (не затрагивая предыдущий сайт),
Добавить анимацию для раскрытия всех выпадающих меню.

```files
project/
        blocks/
            head/
                head.css
                head.js
            foot/
                foot.css
            sidebar/
                sidebar.css
                sidebar.js
        pages/
            index/
                head/
                    head.css            # переопределили вид шапки на заглавной странице
            about/
                about-text/             # добавили новый блок
                    about-text.css
```

Кладем все общее в common и все доработки для сервисов или отдельных страниц раскладываем по разным уровням переопределения. Так common всегда обособлен и может изменяться, а специфика сервисов или каждой страницы остается нетронутой и всегда актуальной. 


#### проект и дизайн





### Эксперименты

Another practical case of redefinition level usage is execute A/B testing in your project, without changing the code of the project itself.

**Example**

You have to make some requested changes in your project. For example, you have to change the header on all pages. You need to test all cases and choose the best one. To test the result and not to ruin your project or not to write long story about `if` statements, you just create new redefinition levels for tests on a project.

You could create as much levels as you want to test new functionality. 

```files
project/            # Project level that works good
    header/         # Current header block of the project
    ...
test-1/             # Level for test 1
    header/         # header block with some changes 
test-2/             # Level for test 2
    header/         # header block with some changes 
test-n/             # Level for test 3
    header/         # header block with some changes 
```

You could build your project including every test layer to view the results (e.g. `project` + changes from `test-1` or `project` + changes from `test-n` or `project` + changes from `test-1` and `test-2`). If some tests are not passed, you could just remove unacceptable layer with these tests from the project assembly. Nothing will crash the current project and affect other tests.


### 

###





Если сравнить уровни со слоями, то базовый слой – это исходная реализация блока, а каждый последующий слой накладывается сверху и дополняет (наследует) или изменяет базовую реализацию.


























1. Переопределения на уровнях
Если нам нужно, на некоторой странице иметь некий superInput, который чем-то отличается от базового input, то нам не обязательно именно придумывать новое имя и новый блок. Можно создать pages/index/blocks/input/input.js и положить туда BEM.DOM.decl('input', ... тут декларация полей и методов ...), эта декларация будет себя вести в точности как наследник базового blocks/input/input.js, т.е. будут доступны правильные this.__base() и this.__self.

На уровне переопределения проекта все блоки, определённые на уровне библиотеки блоков, расширяются с помощью API наследования. Это сделано по аналогии с CSS, ведь если на проекте есть blocks/input/input.css в котором .input { color: red }, то это будет расширять тот lib/blocks/input/input.css, который написан в библиотеке.














Уровни переопределения (http://www.artiom.pro/2012/09/blog-post.html)
Если группа блоков одного проекта (объединённая в папку) подключена к другому проекту напрямую (при помощи частичного чекаута или svn:externals), то любое закоммиченное изменение в таких блоках повлияет на оба проекта.
При разработке одного сайта на основе существующего может потребоваться:
Увеличить шрифт в Шапке на всём сайте (не затрагивая предыдущий сайт),
Добавить анимацию для раскрытия всех выпадающих меню.
То есть необходима возможность переопределять (или доопределять) блоки в разных технологиях только для определённого сайта или только для определённых страниц. Это возможно благодаря уровням переопределения.
Уровень переопределения — это набор реализаций блоков, сгруппированных в одну директорию.

Реализация любого блока библиотеки может быть расширена (или переопределена) на уровне проекта.

С точки зрения сборки страниц:
При сборке каждой страницы можно указать список уровней (директорий), блоки которых будут представлены на странице. Например,
build-page -l blocks-common -l blocks-my my-page.html
С точки зрения файловой структуры:
Проект можно содержать любое количество реализаций блоков. Но на страницу попадут только те, которые явно указаны к применению для сборки этой страницы. Возможно делать разные наборы уровней переопределения для разных разделов сайтов.
С точки зрения JavaScript
Необходима возможность декларативного описания динамического поведения элементов на странице. Конечное поведение должно собираться с разных уровней переопределения. Например,
/* blocks-common/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    ...
  }
});

/* blocks-my/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    this.__base();
    ...
  }
});
С точки зрения шаблонного движка
Для того, чтобы можно было не только переопределять, но и "доопределять" шаблон, нужна возможность вызвать предыдущую реализацию шаблона.
Например, в случае xsl:
<xsl:template match="b:head">
  <div> <!-- Node for extra design -->
    <xsl:apply-imports/>
  </div>
</xsl:template>
С точки зрения архитектуры проекта
При разработке портала из нескольких сайтов можно выделить общую библиотеку блоков, которая станет одним из уровней переопределения для всех сайтов портала. Блоки конкретного сайта — объединить в другой уровень переопределения.
В одном и том же репозитории может храниться реализация сайта для десктопных и мобильных браузеров.
В таком проекте есть уровень переопределения для общей реализации блоков, для мобильной и для десктопной. Различные комбинации уровней дают желаемую реализацию блоков на конкретных страницах.
Примером реализации нескольких уровней переопределения в одном репозитории может служить Open Source библиотека блоков bem-bl.














Уровни переопределения дают возможность:

* расширять или перекрывать исходную реализацию БЭМ-сущностей.
* подключать в проект дополнительные БЭМ-сущности (например, готовые блоки из сторонней библиотеки).
* Настраивать сборку проекта. Логически разделять сборку по требованию проекта. 
