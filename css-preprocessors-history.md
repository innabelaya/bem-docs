## История CSS-препроцессоров в bem-components

Тема CSS-препроцессоров не нова, но все еще очень актуальна для фронтенд-разработчиков. В то время, когда весь мир фронтенд-разработки решил изменить свое отношение к организации стилей и перестать писать чистый CSS, мы не остались в стороне.

В этой небольшой статье мы расскажем вам, чем руководствовались, на чем обожглись и как выбирали CSS-препроцессор для библиотеки [bem-components](https://github.com/bem/bem-components).

## Необходимость выбора препроцессора

Использование препроцессора позволяло уйти от написания длинных названий классов в селекторах, упрощало синтаксис и делало код более чистым и логичным. Возможность использования специализированных под CSS функций и создания вложенных селекторов, добавление переменных и повторное использование свойств CSS делало код модульным и масштабируемым.

Поэтому мы приняли решение начать использовать CSS-препроцессор в bem-components.

Так как препроцессор необходимо было внедрять в уже существующие библиотеки, которые использовались в запущенных проектах, мы сформировали определенные требования, которым препроцессор должен был соответствовать:

* поддержка существующего CSS-кода без дополнительных изменений;
* выразительность и функциональность;
* препроцессор должен был быть написан на JavaScript.

## Плюсы и минусы

Чтобы определиться, мы решили оценить возможности всех представленных на рынке инструментов.

В выборе участвовало несколько кандидатов:

* [Sass](http://sass-lang.com/)
* [Less](http://lesscss.org/)
* [Stylus](http://learnboost.github.io/stylus/)
* [Roole](http://roole.org/)

Все перечисленные препроцессоры предоставляли примерно одинаковую функциональность. 

Они поддерживали:

* переменные (variables);
* миксины (mixings);
* вложенность (nesting);
* циклы и условия (loops and conditions);
* выделение цветом (colour transformation);
* импорт (importing).

Но реализация этих функций и наличие дополнительных «плюшек» сыграли главную роль при выборе препроцессора.

### Sass 

Начнем обзор с **Sass**, самого развитого и известного CSS-препроцессора. 

На момент выбора, Sass поддерживал обширную функциональность, был достаточно быстр и имел большое и активно развивающееся сообщество. 

Однако в Sass было свое видение поддержки некоторых функций, например, `parent reference` (знака `&` для отсылки к родительскому селектору), что затрудняло применение БЭМ-селекторов. Это стало одной из основных причин, почему использование этого препрцессора было не очень удобно в библиотеке bem-components.

Sass был написан на Ruby, что также не облегчало его интеграцию в наши библиотеки, так как все используемые инструменты сборки написаны на JavaScript. Один язык разработки для всех инструментов требовал указания меньшего числа зависимостей, а также снижал порог входа в использование библиотеки для фронтенд-разработчиков.

### Less

**Less** — достаточно быстрый процессор, написанный на JavaScript. Он использовал очень простой синтаксис, основанный на CSS. С него легко было начать знакомство с препроцессорами, но его функциональность была слишком ограничена. Как только появилась бы более или менее сложная проблема, Less'а перестало бы хватать. Например, из-за ограниченных возможностей работы с циклами и массивами он не сможет выполнить все требования наших библиотек.

```
for rule in ((bottom (left center right)) (top (left center right)) (right (top center bottom)) (left (top center bottom))) {
    for secondary in rule[1] {
        {ctx}.popup_direction_{rule[0]}-{secondary} {
            animation-name: popup_theme_normal_ + rule[0];
        }
    }
    for secondary in rule[1] {
        {ctx}.popup_direction_{rule[0]}-{secondary}.popup_visible {
            animation-name: popup_theme_normal_ + rule[0] + _visible;
        }
    }
}
```

### Stylus

**Stylus** – препроцессор, по функциональности близкий к Sass, но в отличие от него написан на JavaScript. 

Stylus считался одним из основных претендентов, подходящих bem-components, так как имел ряд плюсов:

* Очень гибкий синтаксис. Точнее поддержка двух видов синтаксиса. Один позволяет писать код, практически как обычный CSS, другой предоставляет сокращенный синтаксис, основанный на отступах и с минимумом лишних символов.
* Поддержка прозрачных миксинов, благодаря которым любое свойство в CSS можно переопределить на вызов функции.
* Разработка препроцессора в Яндексе и опыт использования его сервисах – Почте и Картах.

К тому времени Stylus был все еще далек от идеала – он имел несколько существенных недостатков, «несовместимых с жизнью» в bem-components. 

Основной проблемой, как бы странно это не звучало, было одно из его основных достоинств – гибкий синтаксис. Поддержка двух видов синтаксиса усложняла архитектуру парсера и накладывала свои ограничения. Сокращенный синтаксис был реализован в полной мере и мог применяться для написания нового CSS-кода. Тогда как основанный на CSS синтаксис не имел полной обратной совместимости с чистым CSS: не было гарантии, что все варианты написания CSS заработают в Stylus.

Еще одним весомым аргументом «против» было то, что Stylus развивался слишком медленно.

Таким образом в конце марта 2013 года было принято решение отказаться и от Stylus 4.0 в пользу молодого и мало кому известного препроцессора Roole.

### Roole

На тот момент (2013 год) **Roole** был самым новым и стремительно развивающимся препроцессором. Хотя он практически не имел своего сообщества и поддерживался одним разработчиком, в его активах уже имелось большинство необходимых bem-components [функций](http://roole.org/documentation/). 

Roole был написан на JavaScript, а его синтаксис практически совпадал с Sass и Stylus. Также Roole умел обращаться с длинными [названиями классов в слекторах](http://noteskeeper.ru/1139/), которые так свойственны БЭМ. Главным плюсом, на наш взгляд, был генерируемый парсер [PEG.js](https://github.com/dmajda/pegjs) с гибкой, легко расширяемой модульной архитектурой. Такой парсер делал Roole очень устойчивым к различным стилям кодирования и не вынуждал разработчика писать код каким-то строго определенным образом.

Благодаря тому, что создатель Roole имел возможность учиться на ошибках, с которыми столкнулись более ранние препроцессоры, вся функциональность была хорошо продумана и доработана. 

Одним из решающих факторов в пользу Roole была поддержка чистого CSS-кода, что давало возможность без дополнительных усилий начать применять его в уже существующих библиотеках и проектах.

Таким образом БЭМ-методология пополнилась еще одним инструментом, а в составе каждого блока наряду с `.css`-файлом появился файл `.roo`.

Использование препроцессора не стало жестким требованием библиотеки. На случай, если сервис использовал какой-либо несовместимый препроцессор или принципиально не хотел использовать Roole, предполагался вариант поставки библиотеки с предкомпилированным CSS.

## Проблемы

После нескольких месяцев использования Roole мы неожиданно столкнулись с серьезной проблемой. То, что раньше считалось основным плюсом препроцессора, оказалось его основной проблемой: парсер PEG.js показал очень плохие результаты по времени парсинга.

Таблица показывает разницу во времени компиляции для всех четырех препроцессоров:

<table>
    <tr>
        <th rowspan="2"> Количество итераций </th>
        <th colspan="4"> Время компиляции, мс </th>
    </tr>
    <tr>
        <th> Roole </th>
        <th> Stylus </th>
        <th> Less </th>
        <th> Sass </th>
    </tr>
    <tr>
        <td> 1 </td>
        <td> 23 </td>
        <td> 10 </td>
        <td> 6 </td>
        <td> 180 </td>
    </tr>
    <tr>
        <td> 10 </td>
        <td> 100 </td>
        <td> 28 </td>
        <td> 11 </td>
        <td> 206 </td>
    </tr>
    <tr>
        <td> 100 </td>
        <td> 3318 </td>
        <td> 118 </td>
        <td> 37 </td>
        <td> 545 </td>
    </tr>
    <tr>
        <td> 1000 </td>
        <td> 5000+ </td>
        <td> 930 </td>
        <td> 207 </td>
        <td> 4000 </td>
    </tr>
</table>

Тесты проводились на основе универсального файла ([bench](https://gist.github.com/Panya/5337f4709264477a2358#file-bench)), компилируемого всеми препроцессорами.

Такая скорость работы парсера была совершенно неприемлемой для использования в реальных «живых» проектах. 

Дополнительным фактором отказа от Roole стало также и то, что его автор перестал отвечать на запросы и вообще прекратил поддержку и разработку своего проекта.

Поэтому нам пришлось пересмотреть свое решение о выборе препроцессора.

## Новый виток в выборе

Выбор нового препроцессора на этот раз оказался не таким мучительным. За недолгий период времени разработчики Stylus и наши коллеги по Яндексу Роман Комаров и Михаил Корепанов хорошо продвинули препроцессор вперед и решили многие проблемы, которые затрудняли переход на инструмент.

После того, как проблемы были решены, препроцессор Stylus, поддержкой и разработкой которого занимаются в Яндексе, стал новым CSS-препроцессором в bem-components.

Миграция с одного препроцессора на другой была несложна: синтаксис и функциональность Roole и Stylus не слишком разнились, а основная масса кода, написанного с использованием какого-либо препроцессора, достаточно просто без изменений преобразовалась в другой синтаксис. 

Однако, были и несовместимые конструкции, которые пришлось переписать руками.

Мы перешли на Stylus, который решил большинство текущих проблем, но вынесли урок — использование его в качестве препроцессора не будет пожизненным выбором. 

Вполне возможно, что в будущем ввиду развития библиотеки нам придется столкнуться с оценкой какого-то нового инструмента. И здесь в выборе мы в первую очередь будем руководствоваться потребностями проекта. Это правило хотим порекомендовать и вам.
