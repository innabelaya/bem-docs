# БЭМ-методология — беда или панацея? //  не могу придумать хорошее название пока :()

И тут мнения разошлись...

Разработчики, которые уже используют БЭМ в своих проектах, с уверенностью заявляют, что БЭМ-методология упрощает их жизнь. Среди новичков и тех, кто не смог разобраться, наоборот, бытует мнение, что БЭМ слишком сложен и переоценен.

Хочется попробовать разобраться, для чего создавалась БЭМ-методология, как её понять и как к ней подступиться вновь прибывшим.

Необходимо вспомнить основную идею методологии: надо использовать БЭМ в том объёме, в котором он принесет наибольшую пользу вашему проекту.

Чтобы понять, что для вас может значить БЭМ, нужно ответить на следующие вопросы:

* [Для чего задумывалась БЭМ-методология?](#Основные-цели-БЭМ-методологии)
* [Как мы пришли к тому, что имеем сейчас?](#История-развития-БЭМ)
* [Как начать применять БЭМ-методологию в своем проекте?](#Как-начать-работать-по-БЭМ)

## Основные цели БЭМ-методологии

Изначально идея создать общую методологию возникла для организации процессов веб-разработки в большой команде, которая работает над разными проектами. Если коротко, то мы хотели не только упорядочить и ускорить разработку, но и снизить порог входа для нового разработчика в проект.

Какие основные цели мы преследовали:
  * Разработчик должен понимать свой код (даже вернувшись к нему через год) и код любого программиста в команде БЭМ-проекта.
  * Любой блок кода может быть использован повторно.
  * Работая в одной команде, разработчики, менеджеры, дизайнеры и верстальщики должны называть одинаковые вещи одинаково. То есть говорить на одном языке.
  * Команды могут обмениваться специалистами для реализации какой-то конкретной функциональности.
  * Порог входа при переходе на новый проект должен быть снижен за счет одинаковой структуры организации всех БЭМ-проектов и одинаковых правил именования всех сущностей;
  * Общая база знаний: возможность не создавать каждый раз всё с нуля, а использовать готовые наработки повторно.

Мы стремились к тому, чтобы количество разработчиков переходило в качество. Это значит, что разработчики должны были знать о работе друг друга и не изобретать заново то, что уже реализовано. Мы хотели создать единую команду, которая работает над разными проектами.

## История развития БЭМ

### Как верстали 10 лет назад

Это сейчас БЭМ вырос в крепкую методологию, которая имеет под собой веские основания для использования. Но когда все начиналось, ни о каких компонентных подходах и модульности в веб-разработке речи не шло. Все верстали сайты, складывая CSS в один файл `project.css`, скрипты, которых было очень мало, — в `project.js`, а картинки — в папку `image`.

В 2005 году обычный проект с точки зрения интерфейса был набором статических HTML-страниц. Вот такой была типичная структура проекта того времени:

```files
about.html      # Для каждой страницы создавался отдельный HTML-файл.
index.html
…
project.css     # Стили находились в одном файле для всего проекта.
project.js      # Скрипты хранились в одном файле для всего проекта.
i/              # Картинки складывались в отдельную директорию.
  yandex.png
```

В верстке использовались `id`, `классы` и `теги`.

```css
/* Картинки на фоне (begin) */
    #foot div
    {
        height: 71px;
        background: transparent url(../i/foot-1.png) 4% 50% no-repeat;
    }

    #foot div div
    {
        background-position: 21%;
        background-image: url(../i/foot-2.png);
    }

    #foot div div div
    {
        background-position: 38%;
        background-image: url(../i/foot-3.png);
    }

    #foot div div div div
    {
        background-position: 54%;
        background-image: url(../i/foot-4.png);
    }
/* Картинки на фоне (end) */
```

Для отделения стилей разных частей страницы добавлялись комментарии с указанием начала и конца:

Например:
```css
/* Graphical banner (begin) */
    .banner
    {
        text-align: center;
    }

    .banner a
    {
        text-decoration: none;
    }
/* Graphical banner (end) */
```

Типичный CSS того времени в большинстве случаев содержал длинный каскад:

```css
/* Albums (begin) */
    .result .albums .info
    {
        padding-right: 8.5em;
    }

    .result .albums .title
    {
        float: left;
        padding-bottom: 0.3em;
    }

    .result .albums .album .listen
    {
        float: left;
        padding: 0.3em 1em 0 1em;
    }

    .result .albums .album .buy
    {
        float: left;
        padding: 0.4em 1em 0 1.6em;
    }

    .result .albums .info i
    {
        font-size: 85%;
    }
/* Albums (end) */
```

Малейшие изменения требовали длительного рефакторинга. Вёрстка в больших проектах была неуправляемой.

Сверстанные статические HTML-страницы нарезались в шаблоны. Если HTML изменялся, все правки было необходимо переносить вручную в шаблон. И наоборот, изменения в шаблонах требовали правок в HTML.

### Основы БЭМ-методологии

Технологий уже на тот момент было много и они изменялись в зависимости от требований проекта, а принципы БЭМ должны были быть универсальны.

Мы приняли решение сформулировать основные правила, по которым будут жить и развиваться наши проекты, и которые никак не будут зависеть от тех технологий и инструментов, которые мы используем.

Чтобы ускорить разработку, необходимо было облегчить поддержку HTML и CSS отдельных компонентов страницы, сделать код менее связанным. Для этого мы разбили страницу на части. Так появилось новое понятие – [блок](#Блок). Блок мог состоять из различных [элементов](#Элемент), которые не использовались вне самого блока. Состояния и поведение блока и элемента можно было задавать с помощью [модификатора](#Модификатор).

Это были три ключевых понятия, на которых основывалось большинство правил. Аббревиатура от трех слов **Б**лок, **Э**лемент и **М**одификатор и стала названием методологии — БЭМ.

#### Блок

Логически и функционально независимый компонент страницы. Блок полностью самодостаточен: у него есть свое поведение, шаблоны, стили, документация и не только. Он может быть использован в любом месте страницы, повторно, даже в другом проекте.

Блоки можно вкладывать в другие блоки, компоновать, использовать для создания более сложных блоков.

#### Элемент

Часть блока, которая не может использоваться в отрыве от него и имеет смысл только в рамках своего родителя. Элементы могут быть обязательными и не обязательными.

Работая с элементами, важно помнить правило: нельзя создавать элементы элементов. Если вложить один элемент в другой, то невозможно будет изменить внутреннюю структуру блока: элементы нельзя будет поменять местами, удалить или добавить без корректировки существующего кода.

#### Модификатор

Свойство блока или элемента, которое меняет их внешний вид, состояние или поведение.
Модификатор имеет имя и значение. Использование модификаторов опционально. У блока/элемента может быть несколько разных модификаторов одновременно.

### Правила именования CSS-селекторов

Все принципы БЭМ формировались и внедрялись постепенно. Мы начали с того, что причиняло наибольшую боль верстальщикам: сформулировали жесткие правила именования CSS-селекторов.

За основу взяли правило: блоки не уникальны, их всегда можно использовать повторно. Поэтому для описания CSS-правил отказались от использования:
  * id
  * тегов
  * селекторов типа — селекторы, которые применяются к DOM-узлам без CSS-класса (элементо-зависимые селекторы)
  * вложенных селекторов
  * глобальных модификаторов
  * глобального сброса правил для всей страницы

Важной определяющей сущностью и в именовании селекторов стал блок:
  * Полное имя элемента/модификатора формируется так, чтобы из него можно было определить принадлежность данного элемента/модификатора к конкретному блоку.
  * По имени модификатора элемента должно быть возможно определить принадлежность данного модификатора к конкретному элементу конкретного блока.

#### Правила формирования имени БЭМ-сущности

  * Каждая БЭМ-сущность должна иметь свой класс.
  * CSS-свойства для блоков, элементов и модификаторов описываются только через классы.
  * CSS-класс для БЭМ-сущности соответствует полному имени этой сущности.
  * Для разделения слов в именах используется дефис (`-`).
  * Для разделения имен блоков, элементов и модификаторов — подчеркиание (`_`). Элемент отделяется от блока двумя подчеркиваниями (`__`). Модификатор — одним (`_`).
  * Имена БЭМ-сущностей записываются с помощью цифр и латинских букв в нижнем регистре.

Мы долго экспериментировали с префиксами и постфиксами в именах, но в итоге отказались от них. Подробности и причины читайте на нашем сайте.

**Пример**

Имя блока — `header`
Имя модификатора блока — `header_theme_green-forest`
Имя элемента блока — `header__search-form`
Имя модификатора элемента — `header__search-form_disabled`

HTML

```html
<div class="header">...</div>
```
CSS

```css
.header { color: red; }
```

### БЭМ в HTML

Мы хотели упорядочить HTML и в итоге пришли к тому, что больше не пишем HTML руками. Подробнее читайте в разделе про инструменты.

В HTML каждая БЭМ-сущность определяется своим классом или классами.

```html
<div class="block-name">
  <i class="block-name__elem"></i>
     ...
</div>
```
В простейшем случае блок соответствует DOM-узлу, один к одному. Но DOM-узел и блок — это не всегда одно и тоже. На одном DOM-узле может совмещаться несколько сущностей. Это называется [миксом](../method/difinitions/definitions.ru.md#Микс). Например, `<div class="block-name block-name_modifier">...</div>`.

С помощью миксов можно:
  * объединять поведение и стили нескольких БЭМ-сущностей без дублирования кода;
  * создавать семантически новые компоненты интерфейса на основе имеющихся блоков, элементов и модификаторов;
  * задавать позицию вложенного блока в родительском, не создавая дополнительных модификаторов. Подробнее, о том, как правильно создавать обёртки в HTML, читайте на [форуме](https://ru.bem.info/forum/656/).

**Пример**

В проекте ссылки реализованы блоком `link`. Необходимо сделать ссылками пункты меню. Существует несколько способов:

* Создать модификатор для пункта меню, который превратит пункт в ссылку. Но в таком случае для реализации модификатора придется скопировать поведение и стили блока `link`. Это приведет к дублированию кода.

  ```html
  <div class="menu-item menu-item_type_link"> ... </div>
  ```

  ```css
  .menu-item {}
  .menu-item_type_link {}
  ```

* Воспользоваться миксом универсального блока `link` и элемента `link` блока `menu`. Микс двух БЭМ-сущностей позволит применить базовую функциональность ссылок из блока `link` и дополнительные CSS-правила из блока `menu` без копирования кода.

  ```html
  <div class="menu-item menu-item__link link"> ... </div>
  ```

### Организация файловой системы

Нас не устраивала первоначальная структура проекта в файловой системе: в ней было сложно ориентироваться и находить нужные технологии сущностей.

Что мы хотели получить от новой структуры:
  * Унифицированную файловую систему любого БЭМ-проекта.
  * Универсальную расширяемую структуру репозитория.
  * Быстрый поиск по файловой системе проекта.
  * Повторное использование кода.
  * Неограниченную возможность переноса кода всего блока из проекта в проект.

Сначала мы попробовали разделить репозиторий проекта по технологиям:

```files
css/
html/
js/
xml/
xsl/
```
Такой подход не показал кардинальных изменений. Поэтому появилось первое деление на [уровни](#Уровень-переопределения) — директории, содержащие другие директории с технологиями блоков.

```files
common/
  css/
  js/
  xml/
  xsl/
example/
  html/
service/
  auto/
    css/
    xml/
```

Мы вынесли общую часть кода, подходящую для всех проектов и платформ, в отдельную директорию `common`. Специфические реализации, необходимые только определённым проектам, складывали отдельно — в директорию `service`. А примеры — в директорию `example`.

Так мы быстрее находили нужный код для отдельных проектов. Но эта структура всё равно не отвечала всем нашим требованиям.

Нам пришлось полностью перевернуть всё с ног на голову: мы вывели на передний план блоки, а не технологии.

>Отныне **блоки первичны, а технологии их реализации — вторичны**.

Официально появляется новое понятие — **технология реализации**.

Блоки могут выполнять разные функции на странице. В зависимости от предназначения блока может меняться его реализация. Под реализацией в БЭМ понимают поведение, внешний вид, шаблоны, документацию к блоку, все виды тестов, картинки и так далее.

Для реализации блока используются различные технологии, например:
  * поведение — JavaScript, CoffeeScript;
  * внешний вид — CSS, Stylus, Sass;
  * шаблоны — Jade, Handlebars, XSL, BEMHTML, BH;
  * документация — Markdown, Wiki, XML.

Выбор технологий реализации не ограничен, разве только требованиями вашего проекта.

>Так БЭМ распространился не только на CSS, но и на все технологии блока.

В новой организации файловой структуры каждая технология реализации представляет собой отдельный файл с соответствующим расширением. Все файлы реализации блока хранятся в директории этого блока.

Всё в проекте перестраивается относительно этого нового принципа. Блок становится ключевым понятием БЭМ. Соответственно, изменяется и структура файловой системы.

#### Правила организации файловой системы БЭМ-проекта

* Блок — отдельная директория в файловой системе. Имя блока и его директории совпадают.
* Реализация блока разделяется на отдельные файлы.
* Файлы, относящиеся к блоку, всегда находятся в его директории.
* Опциональные элементы и модификаторы выносятся в отдельные файлы.
* Проект разделяется на уровни переопределения.

**Пример**

```files
blocks/
  input/                     # Директория блока `input`
    _theme/                  # Директория опционального модификатора `theme`
      input_theme_forest.css # Реализация модификатора `theme` в значении `forest` в технологии CSS
    __clear/                 # Директория опционального элемента `clear`
      input__clear.css       # Реализация элемента `clear` в технологии CSS
      input__clear.png       # Реализация элемента `clear` в технологии PNG
    input.css                # Блок `input` в технологии CSS
    input.js                 # Блок `input` в технологии JavaScript
  button/                    # Директория блока `button`
    button.css
    button.js
    button.png
```

##### Уровень переопределения

Уровнем переопределения мы стали называть директории с реализацией блоков. Появление уровней позволило изменять реализацию блока, добавляя новые свойства (доопределять) или изменяя старые (переопределять) на другом уровне. Конечная реализация блока собирается со всех уровней последовательно.

Если сравнить уровни со слоями, то базовый слой – это исходная реализация блока, а каждый последующий слой накладывается сверху и дополняет (наследует) или изменяет базовую реализацию.

**Пример**

```files
project/           # Уровень проекта
  input/           # Измененная реализация блока `input`
  button/
  header/
library-blocks/    # Уровень библиотеки
  input/           # Базовая реализация блока `input`
  button/
  popup/
```

Уровни переопределения позволяют:
  * Подключать библиотеки и обновлять их, не делая правок в коде.
  * Выделять общие части реализаций блоков на один уровень, а частные случаи (например, специфическую реализацию для отдельных сервисов) — на другой.
  * Разделять проект на платформы. Общую реализацию для всех платформ хранить на одном уровне, а платформо-специфичную — выносить на другой.
  * Избежать копирования кода и создания новых сущностей, если необходимо изменить уже существующую функциональность.


#### Плюсы нового подхода к структуре БЭМ-проекта

Блок в файловой системе полностью независим: все технологии, необходимые для его реализации, находятся в директории этого блока.

Чего мы этим добились:

* **Ускорения разработки**
  * Блоки могут использоваться повторно.
  * Реализация блоков может быть изменена на новом уровне переопределения, не затрагивая при этом базовую функциональность и стили.
  * Блок — независимый компонент страницы и в его директории находится всё, что необходимо для корректного функционирования. Поэтому блоки легко переносить из проекта в проект. Достаточно просто скопировать директорию блока.

* **Ускорение рефакторинга**
  * Разработчик работает к небольшими блоками кода.
  * Технологии реализации одного блока не связаны с технологиями другого. А значит изменения в одном блоке не отображаются в коде другого блока.
  * Одинаковая структура репозитория позволяет быстро ориентироваться в проекте и находить нужные файлы.

* **Универсальная расширяемая система**
  * Количество блоков не ограничено.
  * Количество уровней переопределения не ограничено.
  * Количество технологий не ограничено. Любая новая технология реализации будет находится в файле конкретного блока. Так, когда мы создавали новую файловую структуру, мы не знали, что будем писать unit-тесты на JavaScript. Но когда появилась такая необходимость, мы знали, где разместим эти файлы в проекте.

### Полный стек БЭМ-технологий

По мере внедрения новых правил возникает потребность в собственных инструментах и технологиях.

Стек БЭМ-технологий — это частный случай реализации общих принципов БЭМ-методологии. Так как все технологии создавались с учетом требований наших проектов и развивались постепенно, БЭМ-стек наиболее полно охватывает все возможности, которые предоставляет БЭМ-методология.

В какой-то момент мы отделили методологию от ее практической реализации — платформы. Все части БЭМ-платформы интегрированы для совместной работы, но могут быть использованы и по отдельности. Каждая часть решает конкретную задачу и её можно настраивать под свой процесс и заменять на другие.

#### БЭМ и технологии

В веб-разработке финальный продукт состоит из разных технологий (например, HTML, CSS, JS). Основной принцип БЭМ-методологии — использовать единые термины и подходы к реализации во всех применяемых технологиях.

Чтобы работать в БЭМ-терминах и писать декларативно JavaScript, который можно разделять по уровням переопределения, нам понадобился собственный фреймворк — [i-bem](https://ru.bem.info/technology/i-bem/v2/i-bem-js-common/).

Для работы со структурой веб-страницы в терминах блоков, элементов и модификаторов в БЭМ-методологии используется абстракция над DOM-деревом — **БЭМ-дерево**. БЭМ-дерево описывает состояния, порядок, вложенность и вспомогательные данные всех БЭМ-сущностей, используемых на странице, и может быть выражено любым форматом, который поддерживает древовидную структуру.

**Пример**

Рассмотрим пример DOM-дерева:

<header class="header">
    <img class="logo">
    <form class="search-form">
        <input type="input">
        <button type="button"></button>
    </form>
    <div class="lang-switcher"></div>
</header>

Ему соответствует такое БЭМ-дерево:

```files
header
    logo
    search-form
        input
        button
    lang-switcher
```

Это же БЭМ-дерево будет иметь следующий вид в форматах XML и BEMJSON:

XML

```xml
<block:header>
    <block:logo/>
    <block:search-form>
        <block:input/>
        <block:button/>
    </block:search-form>
    <block:lang-switcher/>
</block:header>
```

BEMJSON

```js
{
    block: 'header',
    content : [
        { block : 'logo' },
        {
            block : 'search-form',
            content : [
                { block : 'input' },
                { block : 'button' }
            ]
        },
        { block : 'lang-switcher' }
    ]
}
```

Мы описываем страницу, которую хотим получить в браузере в виде БЭМ-дерева. БЭМ-дерево может создаваться вручную ([BEMJSON](https://ru.bem.info/technology/bemjson/) — структура данных (объект) JavaScript с набором дополнительных соглашений о представлении БЭМ-сущностей) или строиться автоматически при помощи шаблонизатора [BEMTREE](https://ru.bem.info/technology/bemtree/).

Благодаря БЭМ-дереву мы перестали писать и поддерживать HTML руками. Шаблонизаторы [BEMHTML](https://ru.bem.info/technology/bemhtml/current/rationale/) и [BH](https://ru.bem.info/technology/bh/current/about/) обрабатывают BEMJSON и генерируют HTML.

#### БЭМ и инструменты

Любой БЭМ-проект включает в себя большое количество блоков. Блоки состоят из файлов, которые никак не связаны между собой. Это удобно для разработки и поддержки проекта. Но все эти независимые реализации надо уметь заставить работать вместе и собирать в один проект. Для этого в БЭМ используются сборщики ([ENB](https://ru.bem.info/tools/bem/enb-bem/) [bem-tools](https://ru.bem.info/tools/bem/bem-tools/)) и различного рода оптимизаторы.

Чтобы иметь возможность собрать разрозненные файлы, ничего не знающие друг о друге, используется технология [DEPS](https://ru.bem.info/technology/deps/about/), которая указывает зависимости одного блока от другого или от набора блоков.

Инструменты БЭМ направлены на то, чтоб разработчик писал код так, как ему удобно, а оптимизацией и подключением в проект только нужных файлов в правильном порядке занимались роботы.

#### БЭМ и библиотеки

Для удобства работы с блоками мы объединяли их в библиотеки. Две основные библиотеки вынесли в open source:

* [bem-core](https://ru.bem.info/libs/bem-core/) — базовая библиотека блоков, которая содержит JavaScript-фреймворк `i-bem` и 20 блоков-хелперов для разработки по БЭМ-методологии.
* [bem-components](https://ru.bem.info/libs/bem-components/) — универсальная библиотека готовых визуальных компонентов (блоков). Содержит котролы форм и другие базовые компоненты для построения интерфейсов.

## Как начать работать по БЭМ

Как вы могли заметить, наша команда тоже начинала работу с БЭМ не с полного стека технологий, мы приходили ко всему последовательно. Гибкость БЭМ-методологии позволяет вам настраивать ее под свои текущие процессы.
Это способ организации работы над проектом и каждый начинает его по-своему.

Не существует универсального метода, чтобы начать применять методологию в своем проекте. Каждая конкретная команда встраивает его в свой процесс разработки и использует так, как ей удобно.

### БЭМ для вёрстки

Например, у вас есть проект, в котором вы хотите применить БЭМ только для верстки.
Вы используете в проекте CSS и HTML, значит можно начать с правил именования CSS-селекторов. Это самый распространенный способ использования БЭМ-методологии. Многие команды начинают именно с него. Мы тоже с этого начинали.

Приведенная в статье схема не единственно правильная. Существует ряд [альтернативных схем именования](https://ru.bem.info/method/naming-convention/#Альтернативные-схемы-именования). Выбор всегда остается за вами.

Важно изначально выбирать подходящую вам схему. Задайте класс каждому DOM-узлу и используйте абсолютно-независимые блоки.

```css
.block
.block__elem
.block_size_l
.block__elem_size_l
```

Если это подходит вашему проекту, используйте каскад:

```css
.block
.block .elem
.block_size_l
.block .elem_size_l
```

### Альтернативные способы организации файловой структуры

Если вы или ваша команда не готовы раскладывать все файлы реализации строго по блокам, как описывалось выше, можно применить любую из подходящих вам схем организации файловой системы:

* [flex](#flex)
* [flat](#flat)

Выбор схемы зависит от требований проекта. Любую из этих схем поддерживают [инструменты](https://ru.bem.info/tools/) БЭМ.

Главное соблюдать единообразие в пределах проекта при организации файловой системы и в правилах именования файлов и директорий.

#### flex

Возможные варианты:

* Блоку соответствует отдельная директория.
* Элементы и модификаторы реализованы в отдельных файлах.

```
blocks/
    input/
        input_layout_horiz.css
        input_layout_vertical.css
        input__elem.css
        input.css
        input.js
    button/
```

* Блоку соответствует отдельная директория.
* Элементы и модификаторы реализованы в файлах блока.

```
blocks/
    input/
        input.css
        input.js
    button/
```

* Директории для блоков не используются.
* Элементы и модификаторы реализованы в файлах блока.

```
blocks/
    input.css
    input.js
    button.css
    button.js

```

#### flat

* Директории для блоков не используются.
* Опциональные элеметы и модификаторы реализованы в отдельных файлах.

```
blocks/
    input_type_search.js
    input_type_search.bemhtml
    input__box.bemhtml
    input.css
    input.js
    input.bemhtml
    button.css
    button.js
    button.bemhtml
    button.png
```

#### bem-components в виде Dist

Начиная с версии [2.3.0](https://ru.bem.info/libs/bem-components/v2.3.0/), библиотеку bem-components можно использовать по аналогии с Bootstrap — скачать предварительно собранные файлы библиотеки и добавить их в HTML страницы с помощью элементов `<link>` и `<script>`.

Такой способ поставки библиотеки называется [Dist](https://ru.bem.info/libs/bem-components/v2.3.0/#Подключение-предсобранных-файлов-библиотеки-dist). Поставка библиотеки в виде Dist предоставляет предсобранный CSS- и JavaScript-код и шаблоны. Библиотека подключается ссылками на страницу и не требует сборки.

Сделать это можно разными способами:

* [Подключить файлы с CDN](#Подключение-файлов-с-cdn) — самый быстрый способ.
* [Скачать в виде архива](#Загрузка-в-виде-архива) — возможность выбрать нужную версию сборки.
* [Самостоятельно собрать файлы из исходного кода](#Сбор-файлов-из-исходного-кода) — возможность собрать еще не выпущенную версию библиотеки.
* [Установить с помощью Bower](#Установка-с-помощью-bower)

О том, как работать с подключенными файлами библиотеки, читайте в описании библиотеки в разделе [Работа с библиотекой в виде Dist](https://ru.bem.info/libs/bem-components/v2.3.0/#Работа-с-библиотекой-в-виде-dist).

**Состав предсобранной библиотеки**

Доступны отдельные наборы файлов для трех платформ:
* desktop
* touch-pad
* touch-phone

Каждый набор включает в себя стили (отдельный файл для IE8), JavaScript, BEMHTML-шаблоны, BH-шаблоны, объединение JavaScript-кода и BEMHTML-шаблонов для использования шаблонов в браузере, объединение JavaScript-кода и BH-шаблонов для использования шаблонов в браузере.

В каждый набор также включены аналогичные dev-версии (с сохранением форматирования и комментариев).

##### Подключение файлов с CDN

Самый быстрый и простой способ подключить библиотеку в проект — добавить элементы `<link>` и `<script>` в HTML страницы:

```html
<link rel="stylesheet" href="https://yastatic.net/bem-components/latest/desktop/bem-components.css">
<script src="https://yastatic.net/bem-components/latest/desktop/bem-components.js+bh.js"></script>
```

Схема подключения файла с CDN: `//yastatic.net/название-библиотеки/версия/платформа/имя-файла`.

Пример: `//yastatic.net/bem-components/latest/desktop/bem-components.dev.js+bh.js`.

##### Загрузка в виде архива

Выберите необходимую версию библиотеки и скачайте [архив](https://github.com/bem/bem-components-dist/releases). Распакуйте. Добавьте файлы на страницу с помощью элементов `<link>` и `<script>`:

```html
<link rel="stylesheet" href="desktop/bem-components.css">
<script src="desktop/bem-components.js+bh.js"></script>
```

##### Сбор файлов из исходного кода

Код библиотеки находится на Github: [https://github.com/bem/bem-components](https://github.com/bem/bem-components).

Для сборки выполните следующие команды:

```
# Клонируйте исходный код библиотеки
git clone https://github.com/bem/bem-components.git
# Перейдите в папку библиотеки
cd bem-components
# Установите необходимые зависимости
npm install
# Соберите Dist
npm run dist
```

В результате сборки файлы будут доступны в папке `bem-components-dist`. Подключите файлы в HTML страницы:

```html
<link rel="stylesheet" href="bower_components/bem-components-dist/desktop/bem-components.css">
<script src="bower_components/bem-components-dist/desktop/bem-components.js+bh.js"></script>
```

##### Установка с помощью Bower

При условии, что [Bower](http://bower.io/) уже установлен в ваш проект, выполните следующую команду:

```
bower i bem/bem-components-dist
```

В результате сборки файлы будут доступны в папке `bem-components-dist`. Подключение не отличается от предыдущего способа:

```html
<link rel="stylesheet" href="bower_components/bem-components-dist/desktop/bem-components.css">
<script src="bower_components/bem-components-dist/desktop/bem-components.js+bh.js"></script>
```

#### Заготовка проекта

Чтобы помочь вам быстро создать свой проект по БЭМ, мы создали project-stub — проект с заранее предустановленными технологиями и инструментами. Начинать знакомство с ним стоит с помощью [быстрого старта по БЭМ](https://ru.bem.info/tutorials/quick-start-static/).

Более полный пример использования project-stub описан в документе [Создаем свой проект на БЭМ](https://ru.bem.info/tutorials/start-with-project-stub/).

#### Разработчики делятся опытом

БЭМ-сообщество растет, мы стараемся поддерживать команды, готовые начать использовать БЭМ в своих проектах, делимся с ними опытом.

Уже наступил тот момент, когда опытом начинают делиться те, кто перевел свой проект на БЭМ, стал активным участником сообщества, и не только использует БЭМ, но и готов рассказать о своих впечатлениях.

Команда БЭМ в лице [Виталия Харисова](https://ru.bem.info/authors/harisov-vitaly/) и [Ивана Воищева](https://twitter.com/voischev) выступила на конференции [CodeFest 2015](https://ru.bem.info/talks/codefest-2015/) с докладом [От БЭМ-методологии до Мануфактуры проектов](https://youtu.be/icAwYLLb3Qs?t=1092). Ваня рассказал, как их команда внедряла БЭМ в свой проект, с какими трудностями столкнулась и какие плюсы в итоге получила.

Если у вас возникают вопросы по использованию БЭМ, обязательно задавайте их нам на нашем [форуме](https://ru.bem.info/forum/).
